import .VirtualElement
import ..Graphics
import ..math
    .Capsule
    .Shape
import ..math.BoundingShape
import .Pickable
import ..math.Matrix4
import ..Effect
import ..Program

export default class Node extends VirtualElement implements Shape

    _boundingShape: BoundingShape
    _pickable: Pickable
    //  the worldTransform, transforms from child space to world space
    //  worldTransform
    worldTransform = Matrix4.identity
    //  localTransform
    _transform: Matrix4 | Null
    //  effect to use when rendering this node
    _effect: Effect | Null

    get effect() -> this._effect || null
    set effect(value) ->
        this._effect = value

    get transform() -> this._transform
    set transform(value) ->
        this.invalidate()
        this._transform = value

    get boundingShape() -> this._boundingShape
    set boundingShape(value) ->
        this.invalidate()
        this._boundingShape = value

    get pickable() -> this._pickable
    set pickable(value) ->
        this.invalidate()
        this._pickable = value

    calculateWorldTransform(parentTransform, localTransform) ->
        return Matrix4.multiply(parentTransform, localTransform) ?? Matrix4.identity

    update(g: Graphics): Boolean ->
        var animating = false
        let localTransform = this.transform
        let parentTransform = this.parentNode is Node ? this.parentNode.worldTransform : null
        let worldTransform = this.calculateWorldTransform(parentTransform, localTransform)
        if this.worldTransform != worldTransform
            this.worldTransform = worldTransform
        if this.updateSelf(g)
            animating = true
        if this.updateChildren(g)
            animating = true
        return animating

    updateSelf(g: Graphics) ->
        return false

    updateChildren(g: Graphics) ->
        var animating = false
        var node = this.firstChild
        while node isnt Null
            if node?.update(g)
                animating = true
            node = node.nextSibling
        return animating

    render(g: Graphics) ->
        //  convert to uniforms
        let saveTransform = g.uniforms.modelView
        g.uniforms.modelView = this.worldTransform
        if this._effect is Null
            this.draw(g)
        else
            this._effect.render(g, this.draw.bind(this))
        this.dirty = false
        g.uniforms.modelView = saveTransform

    draw(g: Graphics) ->
        this.drawSelf(g)
        this.drawChildren(g)

    drawSelf(g: Graphics) ->

    drawChildren(g: Graphics) ->
        var node = this.firstChild
        while node isnt Null
            node?.render(g)
            node = node.nextSibling

    collision(a) ->
        for collision in this.collisions(a)
            return collision
        return null

    *collisions(a) ->
        var pickable = this.pickable
        if pickable is Null
            pickable = Pickable.children
        if pickable != Pickable.none
            let localTransform = this.transform
            if localTransform
                a = a.transform(localTransform.inverse())
        if pickable & Pickable.children
            let boundingShape = this.boundingShape
            if (boundingShape is Null || boundingShape.intersectsCapsule(a))
                let reverse = this.pickChildrenReverse
                var child = reverse ? this.lastChild : this.firstChild
                while child isnt Null
                    if child is Node
                        yield* child.collisions(a)
                    child = reverse ? child.previousSibling : child.nextSibling
        if pickable & Pickable.self
            let result = this.collideSelf(a)
            if result isnt Null
                yield result

    get pickChildrenReverse() -> false
    collideSelf(a): Collision | Null -> Null

    onPointerOver: (e: PointerEvent) => Void
    onPointerOut:  (e: PointerEvent) => Void
    onPointerMove: (e: PointerEvent) => Void
    onPointerDown: (e: PointerEvent) => Void
    onPointerUp:   (e: PointerEvent) => Void
