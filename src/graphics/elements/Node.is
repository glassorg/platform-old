import .VirtualElement
import ..Graphics
import ..math
    .Capsule
    .Shape
import ..math.BoundingShape
import .Pickable
import ..math.Matrix4
import ..Effect
import ..Program

export default class Node extends VirtualElement implements Shape

    // is this bounding shape thing good?
    _boundingShape: BoundingShape
    _pickable: Pickable
    _transform: Matrix4 | Null
    _effect: Effect | Null
    dirty: Boolean = false

    get effect() -> this._effect || null
    set effect(value) ->
        this._effect = value

    //  the transform to use for picking.
    //  usually just the inverse of the local transform.
    get pickingTransform() ->
        let transform = this.transform
        return transform ? transform.inverse() : null

    get transform() -> this._transform
    set transform(value) ->
        this.invalidate()
        this._transform = value

    get boundingShape() -> this._boundingShape
    set boundingShape(value) ->
        this.invalidate()
        this._boundingShape = value

    get pickable() -> this._pickable
    set pickable(value) ->
        this.invalidate()
        this._pickable = value

    update(g: Graphics): Boolean ->
        var animating = false
        if this.updateSelf(g)
            animating = true
        if this.updateChildren(g)
            animating = true
        return animating

    updateSelf(g: Graphics) ->
        return false

    updateChildren(g: Graphics) ->
        var animating = false
        var node = this.firstChild
        while node isnt Null
            if node?.update(g)
                animating = true
            node = node.nextSibling
        return animating

    render(g: Graphics) ->
        //  convert to uniforms
        var parentModel
        let localModel = this.transform
        if localModel
            parentModel = g.uniforms.model
            g.uniforms.model = parentModel.multiply(localModel)
        if this._effect is Null
            this.draw(g)
        else
            this._effect.render(g, this.draw.bind(this))
        this.dirty = false
        if parentModel
            g.uniforms.model = parentModel

    draw(g: Graphics) ->
        this.drawSelf(g)
        this.drawChildren(g)

    drawSelf(g: Graphics) ->

    drawChildren(g: Graphics) ->
        var node = this.firstChild
        while node isnt Null
            node?.render(g)
            node = node.nextSibling

    collision(a) ->
        for collision in this.collisions(a)
            return collision
        return null

    *collisions(a) ->
        var pickable = this.pickable
        if pickable is Null
            pickable = Pickable.children
        if pickable != Pickable.none
            let pickingTransform = this.pickingTransform
            if pickingTransform
                a = a.transform(pickingTransform)
            if pickable & Pickable.children
                let boundingShape = this.boundingShape
                if (boundingShape is Null || boundingShape.intersectsCapsule(a))
                    let reverse = this.pickChildrenReverse
                    var child = reverse ? this.lastChild : this.firstChild
                    while child isnt Null
                        if child is Node
                            yield* child.collisions(a)
                        child = reverse ? child.previousSibling : child.nextSibling
            if pickable & Pickable.self
                let result = this.collideSelf(a)
                if result isnt Null
                    yield result

    get pickChildrenReverse() -> false
    collideSelf(a): Collision | Null -> Null

    invalidate() ->
        var node = this
        while node?.dirty == false
            node.dirty = true
            node = node.parentNode

    onpointerover: (e: PointerEvent) => Void
    onpointerout:  (e: PointerEvent) => Void
    onpointermove: (e: PointerEvent) => Void
    onpointerdown: (e: PointerEvent) => Void
    onpointerup:   (e: PointerEvent) => Void
